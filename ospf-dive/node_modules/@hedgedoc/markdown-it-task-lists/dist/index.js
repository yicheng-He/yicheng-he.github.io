"use strict";
/*
 * SPDX-FileCopyrightText: 2020 The HedgeDoc developers (see AUTHORS file)
 *
 * SPDX-License-Identifier: ISC
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var token_1 = __importDefault(require("markdown-it/lib/token"));
var checkboxRegex = /^ *\[([\sx])] /i;
function markdownItTaskLists(md, options) {
    if (options === void 0) { options = { enabled: false, label: false, lineNumber: false }; }
    md.core.ruler.after('inline', 'task-lists', function (state) { return processToken(state, options); });
    md.renderer.rules.taskListItemCheckbox = function (tokens) {
        var token = tokens[0];
        var checkedAttribute = token.attrGet('checked') ? 'checked="" ' : '';
        var disabledAttribute = token.attrGet('disabled') ? 'disabled="" ' : '';
        var line = token.attrGet('line');
        var idAttribute = "id=\"".concat(token.attrGet('id'), "\" ");
        var dataLineAttribute = line && options.lineNumber ? "data-line=\"".concat(line, "\" ") : '';
        return "<input class=\"task-list-item-checkbox\" type=\"checkbox\" ".concat(checkedAttribute).concat(disabledAttribute).concat(dataLineAttribute).concat(idAttribute, "/>");
    };
    md.renderer.rules.taskListItemLabel_close = function () {
        return '</label>';
    };
    md.renderer.rules.taskListItemLabel_open = function (tokens) {
        var token = tokens[0];
        var id = token.attrGet('id');
        return "<label for=\"".concat(id, "\">");
    };
}
exports.default = markdownItTaskLists;
function processToken(state, options) {
    var allTokens = state.tokens;
    for (var i = 2; i < allTokens.length; i++) {
        if (!isTodoItem(allTokens, i)) {
            continue;
        }
        todoify(allTokens[i], options);
        allTokens[i - 2].attrJoin('class', "task-list-item ".concat(options.enabled ? ' enabled' : ''));
        var parentToken = findParentToken(allTokens, i - 2);
        if (parentToken) {
            parentToken.attrJoin('class', 'contains-task-list');
        }
    }
    return false;
}
function findParentToken(tokens, index) {
    var targetLevel = tokens[index].level - 1;
    for (var currentTokenIndex = index - 1; currentTokenIndex >= 0; currentTokenIndex--) {
        if (tokens[currentTokenIndex].level === targetLevel) {
            return tokens[currentTokenIndex];
        }
    }
    return undefined;
}
function isTodoItem(tokens, index) {
    return (isInline(tokens[index]) &&
        isParagraph(tokens[index - 1]) &&
        isListItem(tokens[index - 2]) &&
        startsWithTodoMarkdown(tokens[index]));
}
function todoify(token, options) {
    if (token.children == null) {
        return;
    }
    var id = generateIdForToken(token);
    token.children.splice(0, 0, createCheckboxToken(token, options.enabled, id));
    token.children[1].content = token.children[1].content.replace(checkboxRegex, '');
    if (options.label) {
        token.children.splice(1, 0, createLabelBeginToken(id));
        token.children.push(createLabelEndToken());
    }
}
function generateIdForToken(token) {
    if (token.map) {
        return "task-item-".concat(token.map[0]);
    }
    else {
        return "task-item-".concat(Math.ceil(Math.random() * (10000 * 1000) - 1000));
    }
}
function createCheckboxToken(token, enabled, id) {
    var checkbox = new token_1.default('taskListItemCheckbox', '', 0);
    if (!enabled) {
        checkbox.attrSet('disabled', 'true');
    }
    if (token.map) {
        checkbox.attrSet('line', token.map[0].toString());
    }
    checkbox.attrSet('id', id);
    var checkboxRegexResult = checkboxRegex.exec(token.content);
    var isChecked = (checkboxRegexResult === null || checkboxRegexResult === void 0 ? void 0 : checkboxRegexResult[1].toLowerCase()) === 'x';
    if (isChecked) {
        checkbox.attrSet('checked', 'true');
    }
    return checkbox;
}
function createLabelBeginToken(id) {
    var labelBeginToken = new token_1.default('taskListItemLabel_open', '', 1);
    labelBeginToken.attrSet('id', id);
    return labelBeginToken;
}
function createLabelEndToken() {
    return new token_1.default('taskListItemLabel_close', '', -1);
}
function isInline(token) {
    return token.type === 'inline';
}
function isParagraph(token) {
    return token.type === 'paragraph_open';
}
function isListItem(token) {
    return token.type === 'list_item_open';
}
function startsWithTodoMarkdown(token) {
    return checkboxRegex.test(token.content);
}
